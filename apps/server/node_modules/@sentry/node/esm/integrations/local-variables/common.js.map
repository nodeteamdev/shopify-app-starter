{"version":3,"file":"common.js","sources":["../../../../src/integrations/local-variables/common.ts"],"sourcesContent":["import type { StackFrame, StackParser } from '@sentry/types';\nimport type { Debugger } from 'inspector';\n\nexport type Variables = Record<string, unknown>;\n\nexport type RateLimitIncrement = () => void;\n\n/**\n * Creates a rate limiter that will call the disable callback when the rate limit is reached and the enable callback\n * when a timeout has occurred.\n * @param maxPerSecond Maximum number of calls per second\n * @param enable Callback to enable capture\n * @param disable Callback to disable capture\n * @returns A function to call to increment the rate limiter count\n */\nexport function createRateLimiter(\n  maxPerSecond: number,\n  enable: () => void,\n  disable: (seconds: number) => void,\n): RateLimitIncrement {\n  let count = 0;\n  let retrySeconds = 5;\n  let disabledTimeout = 0;\n\n  setInterval(() => {\n    if (disabledTimeout === 0) {\n      if (count > maxPerSecond) {\n        retrySeconds *= 2;\n        disable(retrySeconds);\n\n        // Cap at one day\n        if (retrySeconds > 86400) {\n          retrySeconds = 86400;\n        }\n        disabledTimeout = retrySeconds;\n      }\n    } else {\n      disabledTimeout -= 1;\n\n      if (disabledTimeout === 0) {\n        enable();\n      }\n    }\n\n    count = 0;\n  }, 1_000).unref();\n\n  return () => {\n    count += 1;\n  };\n}\n\n// Add types for the exception event data\nexport type PausedExceptionEvent = Debugger.PausedEventDataType & {\n  data: {\n    // This contains error.stack\n    description: string;\n  };\n};\n\n/** Could this be an anonymous function? */\nexport function isAnonymous(name: string | undefined): boolean {\n  return name !== undefined && (name.length === 0 || name === '?' || name === '<anonymous>');\n}\n\n/** Do the function names appear to match? */\nexport function functionNamesMatch(a: string | undefined, b: string | undefined): boolean {\n  return a === b || (isAnonymous(a) && isAnonymous(b));\n}\n\n/** Creates a unique hash from stack frames */\nexport function hashFrames(frames: StackFrame[] | undefined): string | undefined {\n  if (frames === undefined) {\n    return;\n  }\n\n  // Only hash the 10 most recent frames (ie. the last 10)\n  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, '');\n}\n\n/**\n * We use the stack parser to create a unique hash from the exception stack trace\n * This is used to lookup vars when the exception passes through the event processor\n */\nexport function hashFromStack(stackParser: StackParser, stack: string | undefined): string | undefined {\n  if (stack === undefined) {\n    return undefined;\n  }\n\n  return hashFrames(stackParser(stack, 1));\n}\n\nexport interface FrameVariables {\n  function: string;\n  vars?: Variables;\n}\n\nexport interface LocalVariablesIntegrationOptions {\n  /**\n   * Capture local variables for both caught and uncaught exceptions\n   *\n   * - When false, only uncaught exceptions will have local variables\n   * - When true, both caught and uncaught exceptions will have local variables.\n   *\n   * Defaults to `true`.\n   *\n   * Capturing local variables for all exceptions can be expensive since the debugger pauses for every throw to collect\n   * local variables.\n   *\n   * To reduce the likelihood of this feature impacting app performance or throughput, this feature is rate-limited.\n   * Once the rate limit is reached, local variables will only be captured for uncaught exceptions until a timeout has\n   * been reached.\n   */\n  captureAllExceptions?: boolean;\n  /**\n   * Maximum number of exceptions to capture local variables for per second before rate limiting is triggered.\n   */\n  maxExceptionsPerSecond?: number;\n}\n"],"names":[],"mappings":"AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,iBAAiB;AACjC,EAAE,YAAY;AACd,EAAE,MAAM;AACR,EAAE,OAAO;AACT,EAAsB;AACtB,EAAE,IAAI,KAAM,GAAE,CAAC,CAAA;AACf,EAAE,IAAI,YAAa,GAAE,CAAC,CAAA;AACtB,EAAE,IAAI,eAAgB,GAAE,CAAC,CAAA;AACzB;AACA,EAAE,WAAW,CAAC,MAAM;AACpB,IAAI,IAAI,eAAgB,KAAI,CAAC,EAAE;AAC/B,MAAM,IAAI,KAAM,GAAE,YAAY,EAAE;AAChC,QAAQ,YAAA,IAAgB,CAAC,CAAA;AACzB,QAAQ,OAAO,CAAC,YAAY,CAAC,CAAA;AAC7B;AACA;AACA,QAAQ,IAAI,YAAa,GAAE,KAAK,EAAE;AAClC,UAAU,YAAA,GAAe,KAAK,CAAA;AAC9B,SAAQ;AACR,QAAQ,eAAA,GAAkB,YAAY,CAAA;AACtC,OAAM;AACN,WAAW;AACX,MAAM,eAAA,IAAmB,CAAC,CAAA;AAC1B;AACA,MAAM,IAAI,eAAgB,KAAI,CAAC,EAAE;AACjC,QAAQ,MAAM,EAAE,CAAA;AAChB,OAAM;AACN,KAAI;AACJ;AACA,IAAI,KAAA,GAAQ,CAAC,CAAA;AACb,GAAG,EAAE,IAAK,CAAC,CAAC,KAAK,EAAE,CAAA;AACnB;AACA,EAAE,OAAO,MAAM;AACf,IAAI,KAAA,IAAS,CAAC,CAAA;AACd,GAAG,CAAA;AACH,CAAA;AACA;AACA;;AAQA;AACO,SAAS,WAAW,CAAC,IAAI,EAA+B;AAC/D,EAAE,OAAO,IAAK,KAAI,cAAc,IAAI,CAAC,MAAA,KAAW,CAAE,IAAG,SAAS,GAAA,IAAO,IAAK,KAAI,aAAa,CAAC,CAAA;AAC5F,CAAA;AACA;AACA;AACO,SAAS,kBAAkB,CAAC,CAAC,EAAsB,CAAC,EAA+B;AAC1F,EAAE,OAAO,CAAA,KAAM,CAAA,KAAM,WAAW,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;AACtD,CAAA;AACA;AACA;AACO,SAAS,UAAU,CAAC,MAAM,EAAgD;AACjF,EAAE,IAAI,MAAO,KAAI,SAAS,EAAE;AAC5B,IAAI,OAAM;AACV,GAAE;AACF;AACA;AACA,EAAE,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,KAAK,CAAC,EAAA,GAAA,CAAA,CAAA,EAAA,KAAA,CAAA,QAAA,CAAA,CAAA,EAAA,KAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,CAAA,KAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,aAAA,CAAA,WAAA,EAAA,KAAA,EAAA;AACA,EAAA,IAAA,KAAA,KAAA,SAAA,EAAA;AACA,IAAA,OAAA,SAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,UAAA,CAAA,WAAA,CAAA,KAAA,EAAA,CAAA,CAAA,CAAA,CAAA;AACA;;;;"}